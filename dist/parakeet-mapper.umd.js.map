{"version":3,"file":"parakeet-mapper.umd.js","sources":["../src/util.ts","../src/map-factory.ts","../src/map-types.ts","../src/convertable.ts","../src/wait.ts"],"sourcesContent":["export type Converter<\n  I extends any = any,\n  O extends any = any\n> = (input: I) => O;\n\nexport type EitherField<\n  T extends object,\n  TKey extends keyof T = keyof T\n> = TKey extends keyof T ? {\n  [P in TKey]-?: T[TKey]\n} & Partial<Record<Exclude<keyof T, TKey>, never>> : never;\n\nexport type InternalPropertyMapper<\n  I extends object,\n  O extends object,\n  key extends keyof O\n> = { [IKey in keyof I]: Converter<I[IKey], O[key]> };\n\nexport type PropertyMapper<\n  I extends object,\n  O extends object,\n  key extends keyof O,\n  ikey extends keyof I\n> = EitherField<Partial<InternalPropertyMapper<I, O, key>>> | (ikey extends keyof I ? {\n  [key: string]: Converter<I[ikey], O[key]>;\n} : never);\n\nexport const isFlag = (\n  v: any\n): v is boolean => typeof v === 'boolean';\n\nexport const isConverter = <I, O>(v: any): v is Converter<I, O> => typeof v === 'function';\n\nexport const isPropKey = (v: any): v is never => typeof v === 'string';\n\nexport const isPropMapper = <\n  I extends object,\n  O extends object,\n  Keys extends keyof O = keyof O\n>(v: any): v is InternalPropertyMapper<I, O, Keys> => typeof v === 'object' && isConverter(v[Object.keys(v)[0]]);\n\nexport const typedKeyOf = <T extends object>(obj: T) => Object.keys(obj) as Array<keyof T>;\n","import {\n  isFlag,\n  isPropKey,\n  isConverter,\n  typedKeyOf,\n  Converter,\n  PropertyMapper\n} from './util';\n\nexport function mapFactory<\n  I extends object,\n  O extends object,\n>(fieldMap: TypeMap<I, O>): Converter<I, O>;\n\nexport function mapFactory<\n  I extends object\n>(): <\n  F extends TypeMap<I>,\n  O extends object = InferOutput<I, F>\n>(fieldMap: F) => Converter<I, O>;\n\nexport function mapFactory<\n  I extends object,\n  O extends object\n>(): <\n  F extends TypeMap<I, O>,\n  RealO extends object = InferOutput<I, F, O>\n>(fieldMap: F) => Converter<I, RealO>;\n\nexport function mapFactory<\n  I extends object,\n  O extends object,\n>(fieldMap?: TypeMap<I, O>) {\n  if (!fieldMap) {\n    return mapFactory;\n  }\n\n  return function (input: I): O {\n    const empty = {} as O;\n\n    if (!fieldMap || !Object.keys(fieldMap).length) {\n      return empty;\n    }\n\n    return typedKeyOf(fieldMap)\n      .reduce((result, key) => {\n        const value = fieldMap[key];\n\n        if (isFlag(value) && value) {\n          result[key] = input[key as string];\n        } else if (isPropKey(value)) {\n          result[key] = input[value];\n        } else if (isConverter<I, O[keyof O]>(value)) {\n          result[key] = value(input);\n        } else if (typeof value === 'object') {\n          const iKey = Object.keys(value)[0];\n\n          // If no value is found in input - get it by the same key as in the output\n          const ivalue = input[iKey] == null ? input[key as string] : input[iKey];\n\n          result[key] = value[iKey](ivalue);\n        }\n\n        return result;\n      }, empty);\n  };\n}\n\nexport type InferConverter<\n  I extends object,\n  T extends TypeMap<I, O>,\n  O extends object = InferOutput<I, T>\n> = Converter<I, O>;\n\nexport type TypeMap<\n  I extends object = any,\n  O extends object = any\n> = {\n  /**\n   * if true - map straight without changes\n   * if false - do not map\n   * if string - map from the according key\n   * if object - map from key in the object using mapper from the value\n   * if function - map by function from the original object\n   */\n  [key in keyof O]:\n    | boolean\n    | keyof I\n    | Converter<I, O[key]>\n    | PropertyMapper<I, O, key, Extract<key, keyof I>>\n    | [Converter<Extract<key, keyof I>, O[key]>]\n};\n\nexport type InferOutput<I extends object, T extends TypeMap<I, O>, O extends object = any> = {\n  [key in keyof T]-?: T[key] extends true\n                      ? I[Extract<key, keyof I>]\n                    : T[key] extends keyof I\n                      ? I[T[key]]\n                    : T[key] extends Converter<I, infer OT>\n                      ? OT\n                    : T[key] extends Partial<Record<string, infer OT>>\n                      ? OT extends Converter<any, infer OKT>\n                        ? OKT\n                      : never\n                    : never;\n};\n","import { TypeMap, InferOutput, mapFactory } from './map-factory';\n\nexport function mapTypes<\n  I extends object\n>(): <\n  F extends TypeMap<I, any>,\n  O extends object = InferOutput<I, F>\n>(input: I, FieldMap: F) => O;\n\nexport function mapTypes<\n  I extends object,\n  O extends object\n>(): <\n  F extends TypeMap<I, any>,\n  RealO extends object = InferOutput<I, F, O>\n>(input: I, FieldMap: F) => RealO;\n\nexport function mapTypes<\n  I extends object,\n  O extends object\n>(input: I, FieldMap: TypeMap<I, O>): O;\n\nexport function mapTypes<\n  I extends object,\n  O extends object\n>(input?: I, FieldMap?: TypeMap<I, O>) {\n  if (!input || !FieldMap) {\n    return mapTypes;\n  }\n\n  return mapFactory(FieldMap)(input);\n}\n","import { Converter } from './util';\n\nexport type ConverterFactory<\n  M extends any[] = any[],\n  T extends object = any,\n  R extends object = any\n> = (...args: M) => Converter<T, R>;\n\nexport interface IConvertableConstructor<\n  C extends ConverterFactory,\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[]\n> {\n  /**\n   * Creates an instance of Convertable.\n   * @param options main options for converter function (typically, the model from server)\n   * @param misc miscellanious arguments for converter function as declared in its definition\n   */\n  new (options: I, ...misc: M): R;\n\n  /**\n   * the converter factory to use for the convertor generation\n   *\n   * Can accept multiple arguments for customization. Those arguments are then transferred to the constructor after the main options.\n   */\n  readonly createConverter: C;\n}\n\nexport interface IReverseConvertableConstructor<\n  C extends ConverterFactory,\n  RC extends ConverterFactory<any, R, I>,\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[],\n  MR extends any[] = RC extends ConverterFactory<infer U> ? U : any[]\n> extends IConvertableConstructor<C, I, R, M> {\n  /**\n   * Creates an instance of Convertable.\n   * @param options main options for converter function (typically, the model from server)\n   * @param misc miscellanious arguments for converter function as declared in its definition\n   */\n  new (options: I, ...misc: M): R;\n\n  /**\n   * reverseConverter has the same signature as the `converter`, used for the reverse conversion back to server types\n   *\n   * Can accept multiple arguments for customization. Those arguments are then transferred to the constructor after the main options.\n   */\n  readonly reverseConverter: RC;\n\n  /**\n   * Converts passed data back to input model using the reverse converter, if any was passed into the `@Convertable` decorator.\n   *\n   * @param options initially converted output to generate resulting input from\n   * @param misc miscellanious arguments for reverseConverter function as declared in its definition\n   */\n  toInput(options: R, ...misc: MR): I;\n}\n\n/**\n * Makes class convertible: adds the ability to convert certain options\n * to the class using its constructor\n *\n * @param converter the converter factory to use for the convertor generation\n *\n * Can accept multiple arguments for customization. Those arguments are then transferred to the constructor after the main options.\n *\n * @returns newly generated convertable class\n*/\nexport function Convertable<\n  C extends ConverterFactory,\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[]\n>(converter: C): IConvertableConstructor<C, I, R, M>;\n\n/**\n * Makes class convertible: adds the ability to convert certain options\n * to the class using its constructor\n *\n * @param converter the converter factory to use for the convertor generation\n *\n * Can accept multiple arguments for customization. Those arguments are then transferred to the constructor after the main options.\n *\n * @param reverseConverter has the same signature as the `converter`, used for the reverse conversion back to server types\n *\n * @returns newly generated convertable class\n*/\nexport function Convertable<\n  C extends ConverterFactory,\n  RC extends ConverterFactory<any, R, I>,\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[],\n  MR extends any[] = RC extends ConverterFactory<infer U> ? U : any[]\n>(converter: C, reverseConverter: RC): IReverseConvertableConstructor<C, RC, I, R, M, MR>;\n\nexport function Convertable<\n  C extends ConverterFactory,\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[],\n\n  RC extends ConverterFactory<any, R, I> = never,\n  MR extends any[] = RC extends ConverterFactory<infer U> ? U : never\n>(converter: C, reverseConverter?: RC) {\n  class Convertable {\n    constructor(options: I, ...misc: M) {\n      const converted = converter(...misc)(options);\n\n      for (const key in converted) {\n        this[key] = converted[key];\n      }\n    }\n\n    public static toInput = reverseConverter ? <Obj extends R>(options: Obj, ...misc: MR) => (\n      reverseConverter(...misc)(options)\n     ) : undefined;\n\n    public static readonly createConverter = converter;\n\n    public static readonly reverseConverter = reverseConverter;\n  }\n\n  return Convertable;\n}\n","import { Converter } from './util';\n\ntype StripPromises<O> = {\n  [key in keyof O]: O[key] extends Promise<infer OK> ? OK : O[key];\n};\n\ntype FlattenPromises<T> = Promise<StripPromises<T>>;\n\nexport function flattenPromises<T>(obj: T): FlattenPromises<T> {\n  const promises: Promise<void>[] = [];\n\n  for (const key in obj) {\n    const value = obj[key];\n\n    if (value instanceof Promise) {\n      promises.push(value.then(resolved => {\n        obj[key] = resolved;\n      }));\n    }\n  }\n\n  return Promise.all(promises)\n    .then(_ => obj as StripPromises<T>);\n}\n\nexport function wait<I, O>(convert: Converter<I, O>): Converter<I, FlattenPromises<O>> {\n  return input => flattenPromises(convert(input));\n}\n"],"names":[],"mappings":";;;;;;EA2BO,IAAM,MAAM,GAAG,UACpB,CAAM,IACW,OAAA,OAAO,CAAC,KAAK,SAAS,GAAA,CAAC;AAE1C,EAAO,IAAM,WAAW,GAAG,UAAO,CAAM,IAA2B,OAAA,OAAO,CAAC,KAAK,UAAU,GAAA,CAAC;AAE3F,EAAO,IAAM,SAAS,GAAG,UAAC,CAAM,IAAiB,OAAA,OAAO,CAAC,KAAK,QAAQ,GAAA,CAAC;AAEvE,EAMO,IAAM,UAAU,GAAG,UAAmB,GAAM,IAAK,OAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAmB,GAAA,CAAC;;WCZ3E,UAAU,CAGxB,QAAwB;MACxB,IAAI,CAAC,QAAQ,EAAE;UACb,OAAO,UAAU,CAAC;OACnB;MAED,OAAO,UAAU,KAAQ;UACvB,IAAM,KAAK,GAAG,EAAO,CAAC;UAEtB,IAAI,CAAC,QAAQ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,EAAE;cAC9C,OAAO,KAAK,CAAC;WACd;UAED,OAAO,UAAU,CAAC,QAAQ,CAAC;eACxB,MAAM,CAAC,UAAC,MAAM,EAAE,GAAG;cAClB,IAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;cAE5B,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,KAAK,EAAE;kBAC1B,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAa,CAAC,CAAC;eACpC;mBAAM,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE;kBAC3B,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;eAC5B;mBAAM,IAAI,WAAW,CAAgB,KAAK,CAAC,EAAE;kBAC5C,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;eAC5B;mBAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;kBACpC,IAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;kBAGnC,IAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,GAAG,KAAK,CAAC,GAAa,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;kBAExE,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC;eACnC;cAED,OAAO,MAAM,CAAC;WACf,EAAE,KAAK,CAAC,CAAC;OACb,CAAC;EACJ,CAAC;;WC5Ce,QAAQ,CAGtB,KAAS,EAAE,QAAwB;MACnC,IAAI,CAAC,KAAK,IAAI,CAAC,QAAQ,EAAE;UACvB,OAAO,QAAQ,CAAC;OACjB;MAED,OAAO,UAAU,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,CAAC;EACrC,CAAC;;WCmEe,WAAW,CAQzB,SAAY,EAAE,gBAAqB;MACnC;UACE,qBAAY,OAAU;cAAE,cAAU;mBAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;kBAAV,6BAAU;;cAChC,IAAM,SAAS,GAAG,SAAS,eAAI,IAAI,EAAE,OAAO,CAAC,CAAC;cAE9C,KAAK,IAAM,GAAG,IAAI,SAAS,EAAE;kBAC3B,IAAI,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;eAC5B;WACF;UAEa,mBAAO,GAAG,gBAAgB,GAAG,UAAgB,OAAY;cAAE,cAAW;mBAAX,UAAW,EAAX,qBAAW,EAAX,IAAW;kBAAX,6BAAW;;cAAK,QACvF,gBAAgB,eAAI,IAAI,EAAE,OAAO,CAAC;WAClC,GAAG,SAAS,CAAC;UAEQ,2BAAe,GAAG,SAAS,CAAC;UAE5B,4BAAgB,GAAG,gBAAgB,CAAC;UAC7D,kBAAC;OAAA,IAAA;MAED,OAAO,WAAW,CAAC;EACrB,CAAC;;WCtHe,eAAe,CAAI,GAAM;MACvC,IAAM,QAAQ,GAAoB,EAAE,CAAC;8BAE1B,GAAG;UACZ,IAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;UAEvB,IAAI,KAAK,YAAY,OAAO,EAAE;cAC5B,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,QAAQ;kBAC/B,GAAG,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC;eACrB,CAAC,CAAC,CAAC;WACL;;MAPH,KAAK,IAAM,GAAG,IAAI,GAAG;kBAAV,GAAG;OAQb;MAED,OAAO,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC;WACzB,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,GAAuB,GAAA,CAAC,CAAC;EACxC,CAAC;AAED,WAAgB,IAAI,CAAO,OAAwB;MACjD,OAAO,UAAA,KAAK,IAAI,OAAA,eAAe,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,GAAA,CAAC;EAClD,CAAC;;;;;;;;;;;;;;;;"}