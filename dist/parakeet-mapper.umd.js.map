{"version":3,"file":"parakeet-mapper.umd.js","sources":["../src/util.ts","../src/map-factory.ts","../src/map-types.ts","../src/convertable.ts","../src/wait.ts"],"sourcesContent":["export type Converter<\r\n  I extends any = any,\r\n  O extends any = any\r\n> = (input: I) => O;\r\n\r\nexport type PropertyFactory<\r\n  I extends any = any,\r\n  O extends any = any,\r\n  key extends keyof O = keyof O\r\n> = (input: I, output: O) => O[key];\r\n\r\nexport type EitherField<\r\n  T extends object,\r\n  TKey extends keyof T = keyof T\r\n> = TKey extends keyof T ? {\r\n  [P in TKey]-?: T[TKey]\r\n} & Partial<Record<Exclude<keyof T, TKey>, never>> : never;\r\n\r\nexport type InternalPropertyMapper<\r\n  I extends object,\r\n  O extends object,\r\n  key extends keyof O\r\n> = { [IKey in keyof I]: Converter<I[IKey], O[key]> };\r\n\r\nexport type PropertyMapper<\r\n  I extends object,\r\n  O extends object,\r\n  key extends keyof O,\r\n  ikey extends keyof I = Extract<key, keyof I>\r\n> = EitherField<Partial<InternalPropertyMapper<I, O, key>>> | (ikey extends keyof I ? {\r\n  [key: string]: Converter<I[ikey], O[key]>;\r\n} : never);\r\n\r\nexport type PropertyConverter<\r\n  I extends object,\r\n  O extends object,\r\n  key extends keyof O,\r\n  R extends O[key] = O[key]\r\n> = readonly [Converter<I[Extract<key, keyof I>], R>];\r\n\r\nexport const isFactory = <I, O, key extends keyof O>(\r\n  v: any\r\n): v is PropertyFactory<I, O, key> => typeof v === 'function';\r\n\r\nexport const isPropKey = (v: any): v is never => typeof v === 'string';\r\n","import {\r\n  isPropKey,\r\n  isFactory,\r\n  Converter,\r\n  PropertyMapper,\r\n  PropertyConverter,\r\n  PropertyFactory\r\n} from './util';\r\n\r\nexport function mapFactory<\r\n  I extends object,\r\n  O extends object,\r\n>(fieldMap: TypeMap<I, O>): Converter<I, O>;\r\n\r\nexport function mapFactory<\r\n  I extends object\r\n>(): <\r\n  F extends TypeMap<I>,\r\n  O extends object = InferOutput<I, F>\r\n>(fieldMap: F) => Converter<I, O>;\r\n\r\nexport function mapFactory<\r\n  I extends object,\r\n  O extends object\r\n>(): <\r\n  F extends TypeMap<I, O>,\r\n  RealO extends object = InferOutput<I, F, O>\r\n>(fieldMap: F) => Converter<I, RealO>;\r\n\r\nexport function mapFactory<\r\n  I extends object,\r\n  O extends object,\r\n>(fieldMap?: TypeMap<I, O>) {\r\n  if (!fieldMap) {\r\n    return mapFactory;\r\n  }\r\n\r\n  return function (input: I): O {\r\n    const result = {} as O;\r\n\r\n    for (const key in fieldMap) {\r\n      const value = fieldMap[key];\r\n      const inputValue = input[key as string];\r\n\r\n      if (value === true) {\r\n        result[key] = inputValue;\r\n      } else if (isPropKey(value)) {\r\n        result[key] = input[value];\r\n      } else if (isFactory<I, O, Extract<keyof O, string>>(value)) {\r\n        result[key] = value(input, result);\r\n      } else if (typeof value === 'object') {\r\n        for (const iKey in (value as object)) {\r\n          const iValue = input[iKey];\r\n\r\n          // If no value is found in input - get it by the same key as in the output\r\n          result[key] = value[iKey](\r\n            iValue == null ? inputValue : iValue\r\n          );\r\n\r\n          // We only need to check the first key\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  };\r\n}\r\n\r\nexport type InferConverter<\r\n  I extends object,\r\n  T extends TypeMap<I, O>,\r\n  O extends object = InferOutput<I, T>\r\n> = Converter<I, O>;\r\n\r\nexport type TypeMap<\r\n  I extends object = any,\r\n  O extends object = any\r\n> = {\r\n  /**\r\n   * if true - map straight without changes\r\n   * if false - do not map\r\n   * if string - map from the according key\r\n   * if object - map from key in the object using mapper from the value\r\n   * if array - map from the key in map using the first value in the array\r\n   * if function - map by function from the original object\r\n   */\r\n  [key in keyof O]:\r\n    | boolean\r\n    | keyof I\r\n    | PropertyFactory<I, O, key>\r\n    | PropertyMapper<I, O, key>\r\n    | PropertyConverter<I, O, key>\r\n};\r\n\r\nexport type InferOutput<I extends object, T extends TypeMap<I, O>, O extends object = any> = {\r\n  [key in keyof T]-?: T[key] extends true\r\n                      ? I[Extract<key, keyof I>]\r\n                    : T[key] extends keyof I\r\n                      ? I[T[key]]\r\n                    : T[key] extends PropertyFactory<I, O, infer K>\r\n                      ? O[K]\r\n                    : T[key] extends Converter<I, infer OT>\r\n                      ? OT\r\n                    : T[key] extends Partial<Record<string, infer OT>>\r\n                      ? OT extends Converter<any, infer OKT>\r\n                        ? OKT\r\n                      : never\r\n                    : T[key] extends readonly [Converter<any, infer R>]\r\n                      ? R\r\n                    : never;\r\n};\r\n","import { TypeMap, InferOutput, mapFactory } from './map-factory';\r\n\r\nexport function mapTypes<\r\n  I extends object\r\n>(): <\r\n  F extends TypeMap<I>,\r\n  O extends object = InferOutput<I, F>\r\n>(input: I, FieldMap: F) => O;\r\n\r\nexport function mapTypes<\r\n  I extends object,\r\n  O extends object\r\n>(): <\r\n  F extends TypeMap<I>,\r\n  RealO extends object = InferOutput<I, F, O>\r\n>(input: I, FieldMap: F) => RealO;\r\n\r\nexport function mapTypes<\r\n  I extends object,\r\n  O extends object\r\n>(input: I, FieldMap: TypeMap<I, O>): O;\r\n\r\nexport function mapTypes<\r\n  I extends object,\r\n  O extends object\r\n>(input?: I, FieldMap?: TypeMap<I, O>) {\r\n  if (!input || !FieldMap) {\r\n    return mapTypes;\r\n  }\r\n\r\n  return mapFactory(FieldMap)(input);\r\n}\r\n","// @ts-nocheck TODO fix for Typescript 4.3.2\r\nimport { Converter } from './util';\r\n\r\nexport type ConverterFactory<\r\n  M extends any[] = any[],\r\n  T extends object = any,\r\n  R extends object = any\r\n> = (...args: M) => Converter<T, R>;\r\n\r\nexport interface IConvertableConstructor<\r\n  C extends ConverterFactory,\r\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\r\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\r\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[]\r\n> {\r\n  /**\r\n   * Creates an instance of Convertable.\r\n   * @param options main options for converter function (typically, the model from server)\r\n   * @param misc miscellanious arguments for converter function as declared in its definition\r\n   */\r\n  new (options: I, ...misc: M): R;\r\n\r\n  /**\r\n   * the converter factory to use for the convertor generation\r\n   *\r\n   * Can accept multiple arguments for customization. Those arguments are then transferred to the constructor after the main options.\r\n   */\r\n  readonly createConverter: C;\r\n}\r\n\r\nexport interface IReverseConvertableConstructor<\r\n  C extends ConverterFactory,\r\n  RC extends ConverterFactory<any, R, I>,\r\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\r\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\r\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[],\r\n  MR extends any[] = RC extends ConverterFactory<infer U> ? U : any[]\r\n> extends IConvertableConstructor<C, I, R, M> {\r\n  /**\r\n   * Creates an instance of Convertable.\r\n   * @param options main options for converter function (typically, the model from server)\r\n   * @param misc miscellanious arguments for converter function as declared in its definition\r\n   */\r\n  new (options: I, ...misc: M): R;\r\n\r\n  /**\r\n   * reverseConverter has the same signature as the `converter`, used for the reverse conversion back to server types\r\n   *\r\n   * Can accept multiple arguments for customization. Those arguments are then transferred to the constructor after the main options.\r\n   */\r\n  readonly reverseConverter: RC;\r\n\r\n  /**\r\n   * Converts passed data back to input model using the reverse converter, if any was passed into the `@Convertable` decorator.\r\n   *\r\n   * @param options initially converted output to generate resulting input from\r\n   * @param misc miscellanious arguments for reverseConverter function as declared in its definition\r\n   */\r\n  toInput(options: R, ...misc: MR): I;\r\n}\r\n\r\n/**\r\n * Makes class convertible: adds the ability to convert certain options\r\n * to the class using its constructor\r\n *\r\n * @param converter the converter factory to use for the convertor generation\r\n *\r\n * Can accept multiple arguments for customization. Those arguments are then transferred to the constructor after the main options.\r\n *\r\n * @returns newly generated convertable class\r\n*/\r\nexport function Convertable<\r\n  C extends ConverterFactory,\r\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\r\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\r\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[]\r\n>(converter: C): IConvertableConstructor<C, I, R, M>;\r\n\r\n/**\r\n * Makes class convertible: adds the ability to convert certain options\r\n * to the class using its constructor\r\n *\r\n * @param converter the converter factory to use for the convertor generation\r\n *\r\n * Can accept multiple arguments for customization. Those arguments are then transferred to the constructor after the main options.\r\n *\r\n * @param reverseConverter has the same signature as the `converter`, used for the reverse conversion back to server types\r\n *\r\n * @returns newly generated convertable class\r\n*/\r\nexport function Convertable<\r\n  C extends ConverterFactory,\r\n  RC extends ConverterFactory<any, R, I>,\r\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\r\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\r\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[],\r\n  MR extends any[] = RC extends ConverterFactory<infer U> ? U : any[]\r\n>(converter: C, reverseConverter: RC): IReverseConvertableConstructor<C, RC, I, R, M, MR>;\r\n\r\nexport function Convertable<\r\n  C extends ConverterFactory,\r\n  I extends object = ReturnType<C> extends Converter<infer U> ? U : any,\r\n  R extends object = ReturnType<C> extends Converter<any, infer U> ? U : any,\r\n  M extends any[] = C extends ConverterFactory<infer U> ? U : any[],\r\n\r\n  RC extends ConverterFactory<any, R, I> = never,\r\n  MR extends any[] = RC extends ConverterFactory<infer U> ? U : never\r\n>(converter: C, reverseConverter?: RC) {\r\n  class Convertable {\r\n    constructor(options: I, ...misc: M) {\r\n      const converted = converter(...misc)(options);\r\n\r\n      for (const key in converted) {\r\n        this[key] = converted[key];\r\n      }\r\n    }\r\n\r\n    public static toInput = reverseConverter ? <Obj extends R>(options: Obj, ...misc: MR) => (\r\n      reverseConverter(...misc)(options)\r\n     ) : undefined;\r\n\r\n    public static readonly createConverter = converter;\r\n\r\n    public static readonly reverseConverter = reverseConverter;\r\n  }\r\n\r\n  return Convertable;\r\n}\r\n","import { Converter } from './util';\r\n\r\nexport type StripPromises<O> = {\r\n  [key in keyof O]:\r\n    | O[key] extends Promise<infer OK>\r\n      ? OK\r\n    : O[key] extends Array<Promise<infer OK>>\r\n      ? Array<OK>\r\n    : O[key];\r\n};\r\n\r\nexport type FlattenPromises<T> = Promise<StripPromises<T>>;\r\n\r\nconst isPromise = (v: any): v is Promise<any> => v instanceof Promise;\r\nconst isPromiseArr = (v: any): v is Promise<any>[] => Array.isArray(v) && v.some(isPromise);\r\n\r\nexport function flattenPromises<T>(obj: T): FlattenPromises<T> {\r\n  const promises: Promise<void>[] = [];\r\n\r\n  for (const key in obj) {\r\n    const value = obj[key];\r\n    const resolve = (\r\n      promise: Promise<any>\r\n    ) => promise.then(res => {\r\n      obj[key] = res;\r\n    });\r\n\r\n    if (isPromise(value)) {\r\n      promises.push(resolve(value));\r\n    } else if (isPromiseArr(value)) {\r\n      promises.push(resolve(Promise.all(value)));\r\n    }\r\n  }\r\n\r\n  return Promise.all(promises)\r\n    .then(_ => obj) as FlattenPromises<T>;\r\n}\r\n\r\nexport function wait<I, O>(convert: Converter<I, O>): Converter<I, FlattenPromises<O>> {\r\n  return input => flattenPromises(convert(input));\r\n}\r\n"],"names":[],"mappings":"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"}