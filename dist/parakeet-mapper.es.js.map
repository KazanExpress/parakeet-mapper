{"version":3,"file":"parakeet-mapper.es.js","sources":["../src/index.ts"],"sourcesContent":["export type ConverterMap<O> = {\n  [key in keyof Partial<O>]: (i: O[key]) => any;\n};\n\nexport type ConvertedMap<\n  O extends object,\n  CM extends ConverterMap<O> = never\n> = {\n  [key in keyof O]: key extends keyof CM ? CM extends [never] ? O[key] : ReturnType<CM[key]> : O[key]\n};\n\nexport function mapFactory<\n  I extends object,\n  O extends object\n>(FieldMap: TypeMap<I, O>): {\n  (input: I): O;\n\n  /**\n   * @param converters - a map of resulting value converters\n   */\n  <CM extends ConverterMap<O>>(\n    input: I,\n    converters: CM\n  ): ConvertedMap<O, CM>;\n\n  /**\n   * Safe net for other types\n   */\n  (\n    input: I,\n    converters: number | string | boolean | null | undefined\n  ): O;\n};\n\nexport function mapFactory<\n  I extends object,\n  O extends object,\n>(FieldMap: TypeMap<I, O>) {\n  return function <CM extends ConverterMap<O> = never>(\n    input: I,\n    converters?: CM\n  ): ConvertedMap<O, CM> {\n    if (\n      !FieldMap ||\n      Array.isArray(FieldMap) ||\n      !Object.keys(FieldMap).length\n    ) {\n      return {} as ConvertedMap<O, CM>;\n    }\n\n    const convert = converters ? (key: string, value: any) => (\n      typeof converters[key] === 'function' ? converters[key](value) : value\n    ) : (_key: string, value: any) => value;\n\n    const result: Partial<O> = {};\n    for (const key in FieldMap) {\n      if (typeof FieldMap[key] === 'boolean' && FieldMap[key]) {\n        result[key] = convert(key, input[key as string] as any);\n        continue;\n      }\n\n      if (typeof FieldMap[key] === 'string') {\n        result[key] = convert(key, input[FieldMap[key as string]] as any);\n        continue;\n      }\n\n      if (typeof FieldMap[key] === 'function') {\n        let mapperValue = (FieldMap[key] as Function)(input);\n        result[key] = convert(key, mapperValue);\n        continue;\n      }\n    }\n\n    return result as ConvertedMap<O, CM>;\n  };\n}\n\nexport function mapTypes<\n  I extends object,\n  O extends object\n>(input: I, FieldMap: TypeMap<I, O>): O {\n  return mapFactory(FieldMap)(input) as O;\n}\n\nexport type TypeMap<\n  I extends object = any,\n  O extends object = any\n> = {\n  /**\n   * if has function - map by funciton\n   * if true - map straight without changes\n   * if false - do not map\n   */\n  [key in keyof Partial<O>]: boolean | keyof Partial<I> | ((obj: I) => O[key]);\n};\n"],"names":[],"mappings":"SAkCgB,UAAU,CAGxB,QAAuB;IACvB,OAAO,UACL,KAAQ,EACR,UAAe;QAEf,IACE,CAAC,QAAQ;YACT,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC;YACvB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,EAC7B;YACA,OAAO,EAAyB,CAAC;SAClC;QAED,MAAM,OAAO,GAAG,UAAU,GAAG,CAAC,GAAW,EAAE,KAAU,MACnD,OAAO,UAAU,CAAC,GAAG,CAAC,KAAK,UAAU,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,KAAK,CACvE,GAAG,CAAC,IAAY,EAAE,KAAU,KAAK,KAAK,CAAC;QAExC,MAAM,MAAM,GAAe,EAAE,CAAC;QAC9B,KAAK,MAAM,GAAG,IAAI,QAAQ,EAAE;YAC1B,IAAI,OAAO,QAAQ,CAAC,GAAG,CAAC,KAAK,SAAS,IAAI,QAAQ,CAAC,GAAG,CAAC,EAAE;gBACvD,MAAM,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,GAAa,CAAQ,CAAC,CAAC;gBACxD,SAAS;aACV;YAED,IAAI,OAAO,QAAQ,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE;gBACrC,MAAM,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,QAAQ,CAAC,GAAa,CAAC,CAAQ,CAAC,CAAC;gBAClE,SAAS;aACV;YAED,IAAI,OAAO,QAAQ,CAAC,GAAG,CAAC,KAAK,UAAU,EAAE;gBACvC,IAAI,WAAW,GAAI,QAAQ,CAAC,GAAG,CAAc,CAAC,KAAK,CAAC,CAAC;gBACrD,MAAM,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;gBACxC,SAAS;aACV;SACF;QAED,OAAO,MAA6B,CAAC;KACtC,CAAC;CACH;AAED,SAAgB,QAAQ,CAGtB,KAAQ,EAAE,QAAuB;IACjC,OAAO,UAAU,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAM,CAAC;CACzC;;;;"}